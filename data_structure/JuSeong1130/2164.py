# https://www.acmicpc.net/problem/2164

"""
1. 어떤생각으로 풀었는지

그냥 deque 이용해서 풀면 되겠다 생각함

어려웠던점
이슈
X

"""
from collections import deque

N = int(input())
arr = [i for i in range(1,N+1)]
dq = deque(arr)

while len(dq) != 1 :
    dq.popleft()
    dq.append(dq.popleft())

print(dq.pop())


아래 영상은 백준처럼 다 제거하는게 아니라 마지막에 누가 남냐는 요세푸스 문제이다.
https://www.youtube.com/watch?v=MHarxFDYBw8 이건 요세푸스 문제 설명
https://namu.wiki/w/%EC%9A%94%EC%84%B8%ED%91%B8%EC%8A%A4%20%EB%AC%B8%EC%A0%9C
5:31초 설명
k번째 사람을 제외하면 n-1명이 남음 그리고 그리고 다시 남은 사람들끼리 다시 게임을 함 
단 시작위치는 다름
숫자   1 2 3 4 5 에서 3번째 위치를 제거하고 나면 3 위치 인덱스 에서 시작되어야함 
단 최대 위치에서 벗어나며 원형으로 돌아야 하므로 k 의 값은 (k % n) + 1로 계산함 
인덱스 0 1 2 3 4

f(1,k) = 1이란게 명확함
점화식은 다음과 같이 구할 수 있다. f(n, k) = (f(n-1,k) + k - 1) % n + 1  (k 에 -1을 한것은 인덱스 때문) 
1. f(n,k)는 n과 k가 주어질때 규칙에 따라 제거 된 생존자의 위치 
2. f(n-1,k)는 남은 n-1명이 k 번째 사람을 제거한 후 생존자의 위치
2. 즉 

---
https://velog.io/@error_io/%EB%B0%B1%EC%A4%80-2164-%EC%B9%B4%EB%93%9C2-Python 
위 블로그 내용에 대한 호석님 설명

2^n일때를 가정해보고 설명한다.
2^n일때 2^n을 한번 줄이면 2^n-1이렇게 된다 즉 이렇게 반씩 줄여가다보면 결국 가운데 있는 값이 남게 된다
예시를 들면 1 2 3 4 에서 1 3 이 없어지고 2 4가 남게되는데 한번더 진행되면 4가 남게된다.

다른 값들을 가지고도 해보면 시작한수 직전에 있는 값이 답이 된다 그럼 이것이 증명된 것이다. 
시작한수 뒤에 있는 값이 답이다 

2^n일때는 알겠는데 그럼 2^n이 아닐때는요?
2^n + k 인경우다 예를들어 6이면 2^2승에다가 + 2를 하는 경우인데
즉 K개 만큼의 수를 제거하면 2^N개 의 숫자가 남게 된다.
여기서는 2개를 제거해주려면 넣고 제거하고 넣고 제거하고 이런 방식을 진행하게 되는데
넣고제거하고가 2개의 인덱스를 타므로 2K를 이동하면된다 
2K를 이동한것은 2개의 값을 제거를 했다는 것이니 남은 2^N증명대로 현재위치에서 뒤에 있는 값을 찾으면 된다.  
2k 뒤에 값이 정답이다.

어려운점
2K를 도출하는 과정
제거한다는게 진짜 제거한다는줄알았는데 아님 그래도 괜찮은가..

    

어떤알고리즘인지만봐라
앞에버리고 뒤로 옮기고 원형이되겠다  환형이다 계속 삥삥돈다. > 연관되서 생각이 된다?
문제를 많이 풀어봐서

최대한 작은 숫자로 증명해보고

식이란건 원리를 통해 도출된거라서

결국엔 2에 1승까지 되는데 둘중하나를 고르는문제가 되는 것











