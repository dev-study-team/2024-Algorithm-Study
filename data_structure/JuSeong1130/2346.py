"""

3 2 1 -3 1 < 현재위치에서 0에서 0번 인덱스 값 더하기 0+3 해서 현재위치는 3 인데 0번쨰 인덱스가 사라지므로 위치를 인덱스 -1 로 조정  
0 1 2 3 4

2 1 -3 1 < 현제 위치 2에서 2번 인덱스 값더하기 현재위치 2에서 - 3이동해서 인덱스 -1인데 뒤에서 한번더 가면되는거 즉 뒤에서 첫번째이므로 인덱스 3으로 변환 하는데 앞에 있는 2번쨰 인덱스가 사라지므로 -1 
0 1 2 3 

2 1 1 < 현재 위치 2에서 2번 인덱스 더하기 2 + 1 3인데 인덱스를 넘어가므로 0으로 변경 그런데 삭제 위치랑 현재 이동할 위치를 비교했을때 이동할 위치가 앞에 있으므로 - 1 안함  
0 1 2 

2 1  
0 1 


2- 3 -1 


+는 % 로하면됨
-는 ? 넘어간다 안넘어간다      4 - 이동할값(3) - 현재 위치2 해주면됨
현재위치가 그럼 3이나오는데 이전위치가 2니까 -1 

현재 위치가 그전 인덱스보다 앞에있냐 뒤에있냐의 차인듯?


"""


"""
1. 현재 위치 꺼내서 
    1. 들어 있는 값으로 이동 시키고
    2. 현재 인덱스를 결과리스트에 넣어준다
2. 현재 위치 삭제한다.
위 생각 보단 아래 생각이 더 깔끔하다

왜냐하면 이동할 위치는 그 이동할 배열의 길이에 맞게 해야하는데 위 생각대로 한다하면 
1. 그전 위치를 가지는 변수 하나
2. 삭제하는 명령줄 하나
위 두개가 더 늘어야 하기 때문이다.

여기 문제에서 2가지 실수를 했는데 
1. 이동할 위치를 찾는 것 

"""
N = int(input()) 

arr =[]
nums = list(map(int, input().split()))
for i in range(N) :
    arr.append([i + 1, nums[i]])

curIdx = 0
result = []
while arr :
    now = arr.pop(curIdx)
    result.append(now[0])
    if now[1] > 0 and arr:
        curIdx = (curIdx + (now[1] - 1)) % len(arr)
    elif now[1] < 0 and arr:
        curIdx = (curIdx + now[1]) % len(arr)

print(*result)

---
실패한 코드

아래코드 문제점
1. 다음 위치를 찾을때 삭제된 길이에서 위치를 찾아야하는데 그러지 않았다.
그런데 그러자고 - 1을 하자니 맨 마지막에 가면 0으로 나누는 예외상황이 발생한다.
2. 다음 위치를 계산 하는 방식을 너무 어렵게 생각 했다.
양수일떄 인덱스 0 1 2 3 4 에서 0번쨰 부터 삭제되고 시작한다. 이러면 1 2 3 4 가 되게 되는데 인덱스로 따지게 되면 0 1 2 3이 되고 현재 위치는 2번이 된다. 
양수는 0 1 2 3 4 일떄 오른쪽으로 움직여야 하는데 2가삭제되어 3의 인덱스가 2로 바뀌니 현재 위치를 - 1 해주어야 한다.

음수는 현재위치가 삭제되어도 상관없이 왼쪽으로 가니 상관 없다
0 1 2 3 4 에서 현재 위치가 2고 -3이 나왔다 해보자 현재 위치가 삭제되면 0 1 3 4가 되게 되는데

위에 처럼 어렵게 생각하지말고 0 1 2 3 4 5 에서 2위치에서 2를 삭제하고 3을 이동하려면 2 + 3 - 1이 되야한다. 그래야 5에서 4인덱스로 줄은 곳으로 이동이 가능하기 떄문
음수는 0 1 2 3 4 5 가 있다하고 1에서 -3 뒤로 간다 생각해보자 그러면 0 5 4가 될것이다. 이걸 어떻게 구하냐?
1 - 3 = -2 가되게되고 여기서 현재 길이 6을 더해주면 뒤에서부터 2칸오게된 값이 되게 된다.
파이썬에서는 아래 성공한 코드와 같이 해주면되지만 자바에서는 모듈러 연산이 달라 모듈러연산을 하기전에 값에 길이를 더해줘야한다.
https://velog.io/@jaehyeonkim2358/Java%EC%99%80-Python%EC%9D%98-%EB%AA%A8%EB%93%88%EB%9F%AC-%EC%97%B0%EC%82%B0

파이썬에서는 -1 % 4 를하면 3이 나오게된다. 쉽게말하면 4길의 인덱스중 1번째 값이 나오면 된다 생각하면된다.
하지만 자바에서는 -1 % 4는 -1이다 그러므로 (curIdx + now[1] + (len(arr) * 1000) % (len(arr ) - 1)을 해줘야한다.
1000은 N의 최대값으로 이보다 클 수 없기때문에 이값을 설정해줬고 이를 더해도 되는 이유는 뒤에서 %로 길이에 관해 모두 나눠주고 남은 값만 도출하기 떄문이다.

배열을 왼쪽으로 이동시키는경우 배열이 연결되어있다 생각해도 좋다
-3 -2 -1 0 1 2 3 이렇게 되어있고 2인덱스에서 -5만큼 이동시키면 -3이 되게 된다. 뒤에서부터 3개를 이동시켰다 생각하고 
여기서 현재 길이를 더해주면 즉 4-3 은 1이니 이동한 위치는 1이다.

성공 코드
N = int(input()) 

arr =[]
nums = list(map(int, input().split()))
for i in range(N) :
    arr.append([i + 1, nums[i]])

curIdx = 0
result = []
for _ in range(N) :
    prevIdx= curIdx
    now = arr[curIdx]
    result.append(now[0])
    if now[1] > 0 and len(arr) - 1 != 0 :
        curIdx = (curIdx + now[1] - 1) % (len(arr) - 1) 
    elif now[1] < 0 and len(arr) - 1 != 0 :
        curIdx = (curIdx + now[1]) % (len(arr ) - 1)
    del arr[prevIdx]
print(*result)


실패 코드
N = int(input()) 

arr =[]
nums = list(map(int, input().split()))
for i in range(N) :
    arr.append([i + 1, nums[i]])

curIdx = 0
result = []
for _ in range(N) :
    prevIdx= curIdx
    now = arr[curIdx]
    result.append(now[0])
    if now[1] > 0 :
        curIdx = (curIdx + now[1]) % (len(arr))
    else :
        curIdx = (len(arr)) - (abs(curIdx + now[1]) % (len(arr)))
    if prevIdx <= curIdx :
            curIdx -= 1
    del arr[prevIdx]
print(*result)




